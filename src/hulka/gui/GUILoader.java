/**   
 *   Copyright (C) 2010  Jonathan Hulka (jon.hulka@gmail.com)
 *
 *   This program is free software: you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 3 of the License, or
 *   (at your option) any later version.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * To do: the config file's InputStream should be closed.
 * Changelog:
 * 2010 08 10 - Jon
 * - Modified loadReader to correctly load the config file from within jar files.
 * 2010 07 08 - Jon
 * - Added <mask> element for menu items - now ctrl, alt, and/or shift can/must be specified explicitly
 */

package hulka.gui;
import hulka.util.MiscUtils;
import hulka.xml.SimpleXMLReader;
import hulka.xml.SimpleXMLToken;
import java.util.HashMap;
import java.io.File;
import java.io.FileInputStream;
import java.io.InputStreamReader;
import java.awt.image.BufferedImage;
import javax.swing.JFrame;
import javax.swing.JMenuBar;
import javax.swing.JMenu;
import javax.swing.JMenuItem;
import javax.swing.JComponent;
import javax.swing.JOptionPane;
import java.awt.event.ActionListener;
import java.awt.event.ActionEvent;
import javax.swing.KeyStroke;

/**
 * This class requires a gui definition file in xml format:<br><br>
 * 1. root element &lt;gui&gt;<br><br>
 * Contents of &lt;gui&gt;:<br>
 * 1.1 optionally one &lt;application&gt; element<br>
 * 1.2 zero or more &lt;document&gt; elements<br>
 * 1.3 optionally one &lt;menubar&gt; element.<br><br>
 * Contents of &lt;application&gt;:<br>
 * 1.1.1 optionally one &lt;icon&gt; (text - path to an image file)<br>
 * 1.1.2 optionally one &lt;name&gt; (text)<br>
 * 1.1.3 optionally one &lt;version&gt; (text)<br><br>
 * Contents of &lt;document&gt;:<br>
 * 1.2.1 one &lt;name&gt; (text)<br>
 * 1.2.2 one &lt;path&gt; (text - path to an html document)<br><br>
 * Contents of &lt;menubar&gt;:<br>
 * 1.3.1 zero or more &lt;menu&gt; elements<br><br>
 * Contents of &lt;menu&gt;:<br>
 * 1.3.1.1 one &lt;name&gt; (text) element<br>
 * 1.3.1.2 zero or more &lt;menu&gt; elements<br>
 * 1.3.1.3 zero or more &lt;menuitem&gt; elements<br><br>
 * Contents of &lt;menuitem&gt;:<br>
 * 1.3.1.3.1 optionally one &lt;id&gt; (text) - each id must be unique; this value will be used to index menu items within the application<br>
 * 1.3.1.3.2 one &lt;name&gt; (text) element<br>
 * 1.3.1.3.3 one &lt;action&gt; (text) this is the identifier for ActionEvents (see {@link ActionCoordinator} for more information on predefined actions)<br>
 * 1.3.1.3.4 optionally one &lt;accelerator&gt; (text - one character) element<br>
 * 1.3.1.3.4 optionally one &lt;shortcut&gt; (text - one character) element<br><br>
 * 1.3.4.3.5 zero or more &lt;mask&gt; (text - "ctrl", "alt", or "shift")
 * 
 * Documents specified in the definition file can be displayed using
 * {@link #showDocument(String)}<br>
 * 
 * This particularly simplifies the process of building menus. Once menus
 * are loaded via the gui definition, all that remains is to
 * connect specific event handlers using the
 * {@link ActionCoordinator#addActionListener(String, ActionListener)}
 * function.<br>
 * 
 * Additional event sources can be connected by registering the
 * ActionCoordinator ( {@link getActionCoordinator()} ).<br>
 * 
 * Here is an example of how this class can be used:<br>
 * <hr>
 * <blockquote><pre>
 * GUILoader guiLoader=new GUILoader("gui.xml");
 * if(guiLoader.loadGUI())
 * {
 *     JFrame frame = guiLoader.getFrame();
 *     ActionCoordinator coordinator = guiLoader.getActionCoordinator();
 *     ActionListener otherListener1 = ...;//another action listener
 *     ActionListener otherListener2 = ...;//another action listener
 *     ActionListener otherListener3 = ...;//another action listener
 *     JButton qButton = new JButton("Quit");
 *     qButton.setActionCommand("application:exit");
 *     JButton oButton = new JButton("Other");
 *     oButton.setActionCommand("other:menucommand");
 *     qButton.addActionListener(coordinator);
 *     oButton.addActionListener(coordinator);
 *     coordinator.addActionListener(otherListener1,"file");
 *     coordinator.addActionListener(otherListener2,null);
 *     coordinator.addActionListener(otherListener3,"other");
 * }
 * </pre></blockquote>
 * <hr>
 * In this example, events generated by qButton will be handled directly
 * by coordinator, since it's action command is predefined, while events
 * generated by oButton will be passed on to otherListener3, then
 * otherListener2. Although otherListener2 is registered first,
 * otherListener3 will receive notification first because it is
 * category-specific.<br>
 * 
 * otherListener1 will not receive notifications for either button, since
 * its category does not match.<br>
 * 
 * The same will happen with any events from menu items defined in
 * gui.xml; predefined action commands will be handled by coordinator,
 * and the rest will be passed on to otherListener1 or otherListener3 -
 * if the category matches. otherListener2 will receive final
 * notification of all unrecognized menu events.<br>
 */
public class GUILoader
{
	private JFrame frame = null;
	private SimpleXMLReader reader;
	private SimpleXMLToken token = null;
	private String guiDef = null;
	private boolean guiLoaded=false;
	private String appVersion=null;

	private HashMap<String,String> folderPaths;
	private HashMap<String,String> documentPaths;
	private HashMap<String,HTMLDialog> documentDialogs;
	private HashMap<String,JMenuItem> menuItems;

	private String appName = null;
	private HTMLDialog creditsDialog = null;
	private HTMLDialog helpDialog = null;
	private ActionCoordinator actionCoordinator;


	private GUILoader(){super();}
	
	/**
	 * Creates a new GUILoader, using the specified definition file
	 * @param guiDefinitionPath path to the xml file containing the gui definition
	 */
	public GUILoader(String guiDefinitionPath)
	{
		actionCoordinator=new ActionCoordinator(this);
		guiDef=guiDefinitionPath;
		folderPaths = new HashMap<String,String>();
		documentPaths = new HashMap<String,String>();
		documentDialogs = new HashMap<String,HTMLDialog>();
		menuItems = new HashMap<String,JMenuItem>();
	}
	
	/**
	 * Attempts to parse the definition file and load the gui
	 * @return true on success, false if an error occurred.
	 */
	public boolean loadGUI()
	{
		
		boolean ok = true;
		if(!guiLoaded)
		{
			ok=loadReader();
			if(ok)
			{
				frame = new JFrame();
				frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
				ok=parseGUIDef();
			}
			else if(frame!=null)
			{
				frame.dispose();
				frame=null;
			}
			guiLoaded=ok;
		}
		else
		{
			showError("Loading GUI","GUI has already been loaded.");
			ok=false;
		}
		return ok;
	}
	
	private boolean loadReader()
	{
		boolean ok=true;

		try
		{
			reader = new SimpleXMLReader(new InputStreamReader(MiscUtils.translateURL(guiDef).openStream()));
//			reader = new SimpleXMLReader(new InputStreamReader(Thread.currentThread().getContextClassLoader().getResourceAsStream(guiDef)));
		}
		catch(Exception ex)
		{
			ok = false;
			showError("Error loading " + guiDef, ex.getMessage());
		}
		return ok;
	}

	private boolean parseGUIDef()
	{
		boolean ok=false;

		do
		{
			ok=parseToken();
		}while(ok && token.type!=SimpleXMLToken.TYPE_ELEMENT_START);

		if(ok)
		{
			if(!token.value.equals("gui"))
			{
				ok=false;
				showError("loading GUI", "Invalid element: '" + token.value + "' - expected 'gui'");
			}
		}

		if(ok) do
		{
			ok = parseToken();
			if( ok &&token.type==SimpleXMLToken.TYPE_ELEMENT_START)
			{
				if(token.value.equals("application")){ok=parseAppSettings();}
				else if(token.value.equals("folder")){ok=parseFolder();}
				else if(token.value.equals("document")){ok=parseDocument();}
				else if(token.value.equals("menubar")){ok=parseMenuBar();}
				else ok=clearElement();//get past unknown elements
			}
		}while(ok && token.type!=SimpleXMLToken.TYPE_ELEMENT_END);
		return ok;
	}
	
	private boolean parseMenuBar()
	{
		JMenuBar menuBar = new JMenuBar();

		boolean ok=true;
		do
		{
			ok=parseToken();
			if(ok && token.type==SimpleXMLToken.TYPE_ELEMENT_START)
			{
				if(token.value.equals("menu"))
				{
					ok=parseMenu(menuBar);
				}
				else ok=clearElement();
			}
		}while(ok && token.type!=SimpleXMLToken.TYPE_ELEMENT_END);
		token.type=SimpleXMLToken.TYPE_NONE;
		if(ok) frame.setJMenuBar(menuBar);
		return ok;
	}
	
	private boolean parseMenu(JComponent c)
	{
		JMenu menu = null;
		boolean ok=true;
		do
		{
			ok=parseToken();
			if(ok && token.type==SimpleXMLToken.TYPE_ELEMENT_START)
			{
				if(token.value.equals("name"))
				{
					ok=extractElementValue();
					if(ok && menu==null)
					{
						menu = new JMenu(token.value);
					}
				}
				else if(token.value.equals("item"))
				{
					if(menu==null)
					{
						ok=false;
						showError("Unnamed menu","Menu name must precede menu items");
					}
					else ok=parseMenuItem(menu);
				}
				else if(token.value.equals("menu"))
				{
					ok=parseMenu(menu);
				}
				else ok=clearElement();
			}
		}while(ok && token.type!=SimpleXMLToken.TYPE_ELEMENT_END);
		token.type=SimpleXMLToken.TYPE_NONE;
		if(ok&&menu!=null)
		{
			if(c instanceof JMenuBar){((JMenuBar)c).add(menu);}
			else if(c instanceof JMenu)((JMenu)c).add(menu);
		}
		return ok;
	}
	
	private boolean parseMenuItem(JMenu menu)
	{
		boolean ok=true;
		String id=null;
		String name=null;
		String action=null;
		String shortcut=null;
		String accelerator=null;
		boolean ctrlMask=false;
		boolean altMask=false;
		boolean shiftMask=false;
		do
		{
			ok=parseToken();
			if(ok && token.type==SimpleXMLToken.TYPE_ELEMENT_START)
			{
				String elementName=token.value;
				ok=extractElementValue();
				if(ok)
				{
					if(elementName.equals("id")){id=token.value;}
					else if(elementName.equals("name")){name=token.value;}
					else if(elementName.equals("action")){action=token.value;}
					else if(elementName.equals("shortcut")){shortcut=token.value;}
					else if(elementName.equals("accelerator")){accelerator=token.value;}
					else if(elementName.equals("mask"))
					{
						if(token.value.equals("ctrl")){ctrlMask=true;}
						else if(token.value.equals("alt")){altMask=true;}
						else if(token.value.equals("shift")){shiftMask=true;}
					}
				}
			}
		}while(ok && token.type!=SimpleXMLToken.TYPE_ELEMENT_END);
		token.type=SimpleXMLToken.TYPE_NONE;
		if(ok)
		{
			ok=false;
			if(name==null){showError("Parsing menu items", "Expected: <name>");}
			else if(name.length()==0){showError("Parsing menu items", "empty name element");}
			if(action==null){showError("Parsing menu items: " + name, "Expected: <action>");}
			else if(action.length()==0){showError("Parsing menu items: " + name, "empty action element");}
			else
			{
				ok=true;
				JMenuItem item = null;
				if(shortcut!=null&&shortcut.length()>0)
				{
					item = new JMenuItem(name,(int)(Character.toUpperCase(shortcut.charAt(0))));
				}else item = new JMenuItem(name);
				if(accelerator!=null &&accelerator.length()>0) item.setAccelerator(KeyStroke.getKeyStroke((int)(Character.toUpperCase(accelerator.charAt(0))),(ctrlMask?ActionEvent.CTRL_MASK:0)|(altMask?ActionEvent.ALT_MASK:0)|(shiftMask?ActionEvent.SHIFT_MASK:0)));
				if(action!=null) item.setActionCommand(action);

				if(id!=null)
				{
					if(menuItems.get(id)==null){menuItems.put(id,item);}
					else{showError("Parsing menu items: " + name, "Duplicate id: " + id + " - item not indexed.");}
				}

				menu.add(item);
				item.addActionListener(actionCoordinator);
			}
		}
		return ok;
	}
	
	private boolean parseFolder()
	{
		boolean ok=true;
		String name=null;
		String path=null;
		do
		{
			ok=parseToken();
			if(ok && token.type==SimpleXMLToken.TYPE_ELEMENT_START)
			{
				String elementName=token.value;
				ok=extractElementValue();
				if(ok)
				{
					if(elementName.equals("name"))
					{
						name=token.value;
					}
					else if(elementName.equals("path"))
					{
						path=token.value;
					}
				}
			}
		}while(ok && token.type!=SimpleXMLToken.TYPE_ELEMENT_END);
		token.type=SimpleXMLToken.TYPE_NONE;
		
		if(ok)
		{
			if(name!=null && path!=null)
			{
				folderPaths.put(name,path);
			}
			else
			{
				showError("Parsing folder definition", "Folder definition missing name or path");
			}
		}
		
		return ok;
	}
	
	private boolean parseDocument()
	{
		boolean ok=true;
		String name=null;
		String path=null;
		String folder=null;
		do
		{
			ok=parseToken();
			if(ok && token.type==SimpleXMLToken.TYPE_ELEMENT_START)
			{
				String elementName=token.value;
				ok=extractElementValue();
				if(ok)
				{
					if(elementName.equals("name"))
					{
						name=token.value;
					}
					else if(elementName.equals("folder"))
					{
						folder=folderPaths.get(token.value);
						if(folder==null)
						{
							ok=false;
							showError("Parsing document definition","Unknown folder");
						}
					}
					else if(elementName.equals("path"))
					{
						path=token.value;
					}
				}
			}
		}while(ok && token.type!=SimpleXMLToken.TYPE_ELEMENT_END);
		token.type=SimpleXMLToken.TYPE_NONE;
		
		if(ok)
		{
			if(name!=null && path!=null)
			{
				if(folder!=null) path=folder+"/"+path;
				documentPaths.put(name,path);
			}
			else
			{
				showError("Parsing document definition", "Document definition missing name or path");
			}
		}
		
		return ok;
	}

	private boolean parseAppSettings()
	{
		boolean ok=true;
		do
		{
			ok=parseToken();
			if(ok && token.type==SimpleXMLToken.TYPE_ELEMENT_START)
			{
				String elementName=token.value;
				ok=extractElementValue();
				if(ok)
				{
					if(elementName.equals("icon"))
					{
						try
						{
							frame.setIconImage(MiscUtils.loadImage(token.value,32,32));
						}
						catch(Exception ex)
						{
							//Missing icon, just report it
							ex.printStackTrace();
						}
					}
					else if(elementName.equals("name"))
					{
						frame.setTitle(token.value);
					}
					else if(elementName.equals("version"))
					{
						appVersion=token.value;
					}
				}
			}
		}while(ok && token.type!=SimpleXMLToken.TYPE_ELEMENT_END);
		token.type=SimpleXMLToken.TYPE_NONE;
		return ok;
	}
	
	/**
	 * Recursively parses elements until the current one is finished
	 */
	private boolean clearElement()
	{
		boolean ok=true;
		do
		{
			ok = parseToken();
			if(ok && token.type==SimpleXMLToken.TYPE_ELEMENT_START)
			{
				clearElement();
				token.type=SimpleXMLToken.TYPE_NONE;
			}
		}while(ok && token.type!=SimpleXMLToken.TYPE_ELEMENT_END);
		return ok;
	}
	
	/**
	 * Helper function to get char data from a leaf element.
	 * Consumes all contents and the element end tag.<br>
	 * On success, the global token will be initialized with the first
	 * char data token parsed, or the empty string if none exist.
	 * Subsequent tokens will be discarded.
	 */
	private boolean extractElementValue()
	{
		//Technically, this should be a leaf element and contain exactly one char data token
		//but to be as fault tolerant as possible, parse through and discard unexpected tokens.
		String tokenValue="";
		int tokenType=SimpleXMLToken.TYPE_NONE;
		boolean ok=true;
		do
		{
			ok=parseToken();
			if(ok)
			{
				if(token.type==SimpleXMLToken.TYPE_CHARACTER_DATA && tokenType!=SimpleXMLToken.TYPE_CHARACTER_DATA)
				{
					tokenType=SimpleXMLToken.TYPE_CHARACTER_DATA;
					tokenValue=token.value;
				}
				else if(token.type==SimpleXMLToken.TYPE_ELEMENT_START)ok=clearElement();
			}
		}while(ok && token.type!=SimpleXMLToken.TYPE_ELEMENT_END);
		if(ok)
		{
			token.type=tokenType;
			token.value=tokenValue;
		}
		return ok;
	}
	
	/**
	 * Helper function - saves some of lines of code
	 */
	private boolean parseToken()
	{
		boolean ok=true;
		token=reader.parseNext(token);
		if(token.type==SimpleXMLToken.TYPE_ERROR)
		{
			ok=false;
			showError("Parsing " + guiDef, token.value);
		}
		return ok;
	}
	
	/**
	 * Displays an error message and prints to System.err
	 * @param title title of the error dialog
	 * @param message error message
	 */
	public void showError(String title, String message)
	{
		System.err.println("error - " + title + ": " + message);
		JOptionPane.showMessageDialog(frame,message,title,JOptionPane.ERROR_MESSAGE);
	}
	
	/**
	 * Displays an html document in a popup window.
	 * The document must be specified in the gui definition file.
	 * @param name document name as specified in the gui definition file
	 */
	public void showDocument(String name)
	{
		//get the document path
		String path=documentPaths.get(name);
		boolean ok=path!=null;
		
		if(ok)
		{
			//Check if a dialog exists for this document
			HTMLDialog dialog=documentDialogs.get(name);
			//If not, create one
			if(dialog==null)
			{
				try
				{
					dialog = new HTMLDialog(frame,appName,MiscUtils.translateURL(path));
					documentDialogs.put(name,dialog);
				}
				catch(Exception ex)
				{
					ok=false;
					showError("Loading document " + name, ex.getMessage());
				}
			}
			//Display the dialog
			if(ok)
			{
				dialog.setSize(600,500);
				dialog.setLocationRelativeTo(null);
				dialog.setVisible(true);
			}
		}else showError("Loading document " + name, "Unknown document");
	}
	
	/**
	 * Returns the main application window.
	 * @return the main application window
	 */
	public JFrame getFrame()
	{
		return frame;
	}
	
	/**
	 * Shuts down the application.
	 */
	public void exit(int code)
	{
		if(frame!=null)
		{
			frame.setVisible(false);
			frame.dispose();
			System.exit(code);
		}
	}
	
	/**
	 * Gets the associated ActionCoordinator.
	 * @return the ActionCoordinator for this gui instance.
	 */
	public ActionCoordinator getActionCoordinator()
	{
		return actionCoordinator;
	}
	
	/**
	 * Gets a menu item by its id (specified in the gui definition file).
	 * @param id as specified in the gui definition file.
	 * @return the menu item if indexed, null otherwise.
	 */
	public JMenuItem getMenuItem(String id)
	{
		return menuItems.get(id);
	}
	
	public String getAppVersion()
	{
		return appVersion;
	}
	
	public String getFolderPath(String name)
	{
		return folderPaths.get(name);
	}
}
